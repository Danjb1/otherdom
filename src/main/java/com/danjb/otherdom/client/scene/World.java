package com.danjb.otherdom.client.scene;

import java.util.HashMap;
import java.util.Map;

import org.joml.Vector3f;

public class World {

    /////////////////////////////////////////////////////////////////////////
    
    /**
     * Class representing a key to retrieve a TerrainSection.
     * 
     * @author Dan Bryce
     */
    private static class SectionKey {
        
        private int x, y;
        
        public SectionKey(int x, int y){
            this.x = x;
            this.y = y;
        }

        /**
         * SectionKeys that are "equal" must return the same hash code.
         * This is very important for the retrieval of TerrainSections.
         * 
         * Auto-generated by Eclipse.
         */
        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + x;
            result = prime * result + y;
            return result;
        }

        /**
         * SectionKeys that contain the same co-ordinates are considered equal.
         * This is very important for the retrieval of TerrainSections.
         * 
         * (Mostly) auto-generated by Eclipse.
         */
        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            SectionKey other = (SectionKey) obj;
            return x == other.x && y == other.y;
        }

    }

    /////////////////////////////////////////////////////////////////////////

    public static enum CompassDirection {
        NORTH,
        NORTHEAST,
        EAST,
        SOUTHEAST,
        SOUTH,
        SOUTHWEST,
        WEST,
        NORTHWEST
    }

    public static final int NUM_COMPASS_DIRECTIONS = 8;
    
    /**
     * Angle covered by each compass direction, in degrees.
     */
    public static final int COMPASS_ANGLE_INCREMENT = 
            360 / NUM_COMPASS_DIRECTIONS;
    
    /**
     * Axis that defines the east -> west direction.
     * That is, east is low in this axis and west is high.
     */
    public static final Vector3f X_AXIS = new Vector3f(1.0f, 0.0f, 0.0f);

    /**
     * Axis that defines the north -> south direction.
     * That is, north is low in this axis and south is high.
     */
    public static final Vector3f Y_AXIS = new Vector3f(0.0f, 1.0f, 0.0f);

    /**
     * Axis that defines the floor -> sky direction.
     * That is, valleys are low in this axis and hills are high.
     * Sea-level is defined as z = 0.
     */
    public static final Vector3f Z_AXIS = new Vector3f(0.0f, 0.0f, 1.0f);

    /**
     * Grid of TerrainSections that make up the world.
     * 
     * The reason we use a Map instead of an array is that we want to be able to
     * support:
     * 1) An expanding world.
     * 2) Negative grid co-ordinates.
     */
    private Map<SectionKey, TerrainSection> terrainSections = new HashMap<>();

    private Map<Integer, Player> players = new HashMap<>();
    
    public void addPlayer(int id, Player player){
        players.put(id, player);
    }
    
    public Map<Integer, Player> getPlayers() {
        return players;
    }
    
    /**
     * Retrives the TerrainSection at the given co-ordinates.
     * @param sectionX
     * @param sectionZ
     * @return
     */
    public TerrainSection getSection(int sectionX, int sectionZ){
        SectionKey key = new SectionKey(sectionX, sectionZ);
        TerrainSection section = terrainSections.get(key);
        if (section == null){
            // Automatically expand when new TerrainSections are needed
            TerrainSection newSection = new TerrainSection(sectionX, sectionZ);
            terrainSections.put(key, newSection);
            return newSection;
        }
        return section;
    }

    public Player getCurrentPlayer() {
        return players.get(0);
    }

    public void update() {
        for (Player player : players.values()){
            player.update();
        }
    }
    
}
